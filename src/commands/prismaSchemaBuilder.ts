import { WentConfig, WentConfigEntity, WentConfigEntityField } from '../types/went.config'; // Ensure this path is correct for your type definitions

// Helper to convert WentConfigEntityField to Prisma field string
function fieldToPrismaString(fieldName: string, fieldConfig: WentConfigEntity['fields'][string]): string {
  // Check if fieldConfig is a simple string (shorthand for type or relation)
  if (typeof fieldConfig === 'string') {
    // If it contains '@relation', assume it's a full relation string
    if (fieldConfig.includes('@relation')) {
      return `${fieldName} ${fieldConfig}`;
    }
    // Otherwise, assume it's a type possibly with modifiers like 'String' or 'Post[]'
    return `${fieldName} ${fieldConfig}`;
  }

  // If it's an object (WentConfigEntityField)
  const typedFieldConfig = fieldConfig as WentConfigEntityField; // Type assertion
  let parts: string[] = [fieldName];
  
  let finalType = typedFieldConfig.type;
  if (typedFieldConfig.isOptional && !finalType.endsWith('?')) {
    finalType += '?';
  }
  parts.push(finalType);


  if (typedFieldConfig.isId) parts.push('@id');
  if (typedFieldConfig.isUnique) parts.push('@unique');
  

  if (typedFieldConfig.defaultValue !== undefined) {
    if (typeof typedFieldConfig.defaultValue === 'string') {
      // Check if it's a Prisma function like cuid(), uuid(), now() or an enum value
      // A simple regex for functions like cuid() or now()
      // Or if it's an Uppercase word (potential enum) and its type is also an Uppercase word (potential enum type)
      if (/^[a-zA-Z_][a-zA-Z0-9_]*\(\)$/.test(typedFieldConfig.defaultValue) || 
          (/^[A-Z_][A-Z0-9_]*$/.test(typedFieldConfig.defaultValue) && /^[A-Z_][A-Z0-9_]*$/.test(typedFieldConfig.type) && typedFieldConfig.type.toUpperCase() === typedFieldConfig.defaultValue.toUpperCase())) {
        parts.push(`@default(${typedFieldConfig.defaultValue})`);
      } else {
        // Otherwise, treat as a string literal
        parts.push(`@default("${typedFieldConfig.defaultValue}")`);
      }
    } else if (typeof typedFieldConfig.defaultValue === 'boolean' || typeof typedFieldConfig.defaultValue === 'number') {
      parts.push(`@default(${typedFieldConfig.defaultValue})`);
    }
  }
  // Add more conversions for relations (@relation), other attributes (@updatedAt) later
  return parts.join('  ');
}

// Default User model for authentication
const getDefaultUserModel = () => `
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Add your custom fields here
  
  // Uncomment for auth setup with Next-Auth
  // accounts      Account[]
  // sessions      Session[]
}

// Uncomment for auth setup with Next-Auth
// model Account {
//   id                String  @id @default(cuid())
//   userId            String
//   type              String
//   provider          String
//   providerAccountId String
//   refresh_token     String? @db.Text
//   access_token      String? @db.Text
//   expires_at        Int?
//   token_type        String?
//   scope             String?
//   id_token          String? @db.Text
//   session_state     String?
//
//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)
//
//   @@unique([provider, providerAccountId])
// }
//
// model Session {
//   id           String   @id @default(cuid())
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
// }
//
// model VerificationToken {
//   identifier String
//   token      String   @unique
//   expires    DateTime
//
//   @@unique([identifier, token])
// }
`;

export function generatePrismaSchema(config: WentConfig): string {
  // Determine the database provider
  const dbProvider = config.database?.provider || "postgresql"; // Default to postgresql if not specified
  
  if (!config.prisma || !config.prisma.entities || config.prisma.entities.length === 0) {
    console.warn("No Prisma entities defined in went.config.ts under the 'prisma.entities' key. Using default User model.");
    return `// This schema is generated by the 'went' CLI with default User model.
// It's recommended to review and adjust this schema before running migrations.

datasource db {
  provider = "${dbProvider}"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

${getDefaultUserModel()}
`;
  }

  let schemaString = `
// This schema is generated by the 'went' CLI.
// It's recommended to review and adjust this schema before running migrations.

datasource db {
  provider = "${dbProvider}"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
  `;

  for (const entity of config.prisma.entities) {
    schemaString += `\nmodel ${entity.name} {\n`;
    for (const [fieldName, fieldConfig] of Object.entries(entity.fields)) {
      schemaString += `  ${fieldToPrismaString(fieldName, fieldConfig)}\n`;
    }
    schemaString += `}\n`;
  }

  return schemaString;
}